/* Code generated by sqlgen */

// Add{{ .structName }} inserting {{ .fullName }} into database
func Add{{ .structName }}(ctx context.Context, way, tag string, objects ...interface{}) error {
	var b *sqlbuilder.InsertBuilder
	switch way {
	case dbhelper.Insert:
		b = dbhelper.S({{ .fullName }}{}).InsertIntoForTag({{ .table }}, tag, objects...)
	case dbhelper.InsertIgnore:
		b = dbhelper.S({{ .fullName }}{}).InsertIgnoreIntoForTag({{ .table }}, tag, objects...)
	case dbhelper.Replace:
		b = dbhelper.S({{ .fullName }}{}).ReplaceIntoForTag({{ .table }}, tag, objects...)
	default:
		return fmt.Errorf("invalid insert way: %s", way)
	}

	if _, err := dbhelper.ExecB(ctx, {{ .db }}, b); err != nil {
		ecmlog.ErrorEx(ctx, "ExecB failed", "err", err)
		return err
	}
	return nil
}

// Delete{{ .structName }} deleting {{ .fullName }} from database
func Delete{{ .structName }}(ctx context.Context, cond dbhelper.DelCondFunc) error {
	b := dbhelper.S({{ .fullName }}{}).DeleteFrom({{ .table }})
	cond(b)

	if _, err := dbhelper.ExecB(ctx, {{ .db }}, b); err != nil {
		ecmlog.ErrorEx(ctx, "ExecB failed", "err", err)
		return err
	}
	return nil
}

// Update{{ .structName }} updating {{ .fullName }} in database
func Update{{ .structName }}(ctx context.Context, tag string, cond dbhelper.UpdateCondFunc) error {
	b := dbhelper.S({{ .fullName }}{}).UpdateForTag({{ .table }}, tag, struct{}{})
	cond(b)

	if _, err := dbhelper.ExecB(ctx, {{ .db }}, b); err != nil {
		ecmlog.ErrorEx(ctx, "Exec failed", "err", err)
		return err
	}
	return nil
}

// Get{{ .structName }} getting {{ .fullName }} from database
func Get{{ .structName }}(ctx context.Context, cond dbhelper.CondFunc) (*{{ .fullName }}, error) {
	return GetTag{{ .structName }}(ctx, "", cond)
}

// GetTag{{ .structName }} getting {{ .fullName }} from database
func GetTag{{ .structName }}(ctx context.Context, tag string, cond dbhelper.CondFunc) (*{{ .fullName }}, error) {
	b := dbhelper.S({{ .fullName }}{}).SelectFromForTag({{ .table }}, tag)
	cond(b)

	var result {{ .fullName }}
	if err := dbhelper.GetTagStruct(ctx, {{ .db }}, tag, &result, b); err != nil {
		ecmlog.ErrorEx(ctx, "GetTagStruct failed", "err", err)
		return nil, err
	}
	return &result, nil
}

// Pull{{ .structName }} pulling {{ .fullName }} from database
func Pull{{ .structName }}(ctx context.Context, cond dbhelper.CondFunc) ([]{{ .fullName }}, error) {
	return PullTag{{ .structName }}(ctx, "", cond)
}

// PullTag{{ .structName }} pulling {{ .fullName }} from database
func PullTag{{ .structName }}(ctx context.Context, tag string, cond dbhelper.CondFunc) ([]{{ .fullName }}, error) {
	b := dbhelper.S({{ .fullName }}{}).SelectFromForTag({{ .table }}, tag)
	cond(b)

	var result []{{ .fullName }}
	if err := dbhelper.PullTagStructs(ctx, {{ .db }}, tag, &result, b); err != nil {
		ecmlog.ErrorEx(ctx, "PullTagStructs failed", "err", err)
		return nil, err
	}
	return result, nil
}

// CountPull{{ .structName }} pulling {{ .fullName }} from database, with total count
func CountPull{{ .structName }}(ctx context.Context, cond dbhelper.CondFunc) ([]{{ .fullName }}, int64, error) {
	return CountPullTag{{ .structName }}(ctx, "", cond)
}

// CountPullTag{{ .structName }} pulling {{ .fullName }} from database, with total count
func CountPullTag{{ .structName }}(ctx context.Context, tag string, cond dbhelper.CondFunc) ([]{{ .fullName }}, int64, error) {
	b := dbhelper.S({{ .fullName }}{}).SelectFromForTag({{ .table }}, tag)
	cond(b)

	var result []{{ .fullName }}
	if err := dbhelper.PullTagStructs(ctx, {{ .db }}, tag, &result, b); err != nil {
		ecmlog.ErrorEx(ctx, "PullTagStructs failed", "err", err)
		return nil, 0, err
	}
	count, err := dbhelper.GetCount(ctx, {{ .db }}, b)
	if err != nil {
		ecmlog.ErrorEx(ctx, "GetCount failed", "err", err)
		return nil, 0, err
	}
	return result, count, nil
}

{{ range $m, $t := .converters }}// Map{{$m}}To{{$.structName}} mapping {{ $.fullName }} by it's {{$m}}
func Map{{$m}}To{{$.structName}}(objs []{{ $.fullName }}, err error) (map[{{$t}}]*{{ $.fullName }}, error) {
	if err != nil {
		return nil, err
	}

	result := make(map[{{$t}}]*{{ $.fullName }}, len(objs))
	for i := range objs {
		result[objs[i].{{$m}}] = &objs[i]
	}
	return result, nil
}

{{ end -}}

{{ range $m, $t := .groupers }}// Group{{$.structName}}By{{$m}} grouping {{ $.fullName }} by it's {{$m}}
func Group{{$.structName}}By{{$m}}(objs []{{ $.fullName }}, err error) (map[{{$t}}][]{{ $.fullName }}, error) {
	if err != nil {
		return nil, err
	}

	result := make(map[{{$t}}][]{{ $.fullName }})
	for i := range objs {
		result[objs[i].{{$m}}] = append(result[objs[i].{{$m}}], objs[i])
	}
	return result, nil
}

{{ end -}}

/* Code generated by sqlgen */
