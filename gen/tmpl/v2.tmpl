package {{ .outPkg }}

// Code generated by sqlgen, please add your function in {{ .extFile }}

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/huandu/go-sqlbuilder"

	{{ .dbHelperPkg }}
	{{ .ecmLogPkg }}
)


// {{ .ormStruct }} is ORM struct to {{ .fullName }}
type {{ .ormStruct }} struct {
	ORM   *dbhelper.Struct
	DB    *sql.DB
	Table string
}

// {{ .ormName }} is ORM object to {{ .fullName }}
var {{ .ormName }} = &{{ .ormStruct }}{
	ORM:   dbhelper.NewStruct({{ .fullName }}{}),
	DB:    {{ .db }},
	Table: {{ .table }},
}

// Add inserting {{ .fullName }} into database
func (m *{{ .ormStruct }}) Add(ctx context.Context, way, tag string, objects ...interface{}) error {
	var b *sqlbuilder.InsertBuilder
	switch way {
	case dbhelper.Insert:
		b = m.ORM.InsertIntoForTag(m.Table, tag, objects...)
	case dbhelper.InsertIgnore:
		b = m.ORM.InsertIgnoreIntoForTag(m.Table, tag, objects...)
	case dbhelper.Replace:
		b = m.ORM.ReplaceIntoForTag(m.Table, tag, objects...)
	default:
		return fmt.Errorf("invalid insert way: %s", way)
	}

	expr, args := b.Build()
	if _, err := m.ORM.Exec(ctx, m.DB, expr, args...); err != nil {
		ecmlog.ErrorEx(ctx, "Exec failed", "err", err)
		return err
	}
	return nil
}

// Delete deleting {{ .fullName }} from database
func (m *{{ .ormStruct }}) Delete(ctx context.Context, cond dbhelper.DelCondFunc) error {
	b := m.ORM.DeleteFrom(m.Table)
	cond(b)

	expr, args := b.Build()
	if _, err := m.ORM.Exec(ctx, m.DB, expr, args...); err != nil {
		ecmlog.ErrorEx(ctx, "Exec failed", "err", err)
		return err
	}
	return nil
}

// Update updating {{ .fullName }} in database
func (m *{{ .ormStruct }}) Update(ctx context.Context, cond dbhelper.UpdateCondFunc) error {
	b := sqlbuilder.NewUpdateBuilder().Update(m.Table)
	cond(b)

	expr, args := b.Build()
	if _, err := m.ORM.Exec(ctx, m.DB, expr, args...); err != nil {
		ecmlog.ErrorEx(ctx, "Exec failed", "err", err)
		return err
	}
	return nil
}

// TagGet getting {{ .fullName }} from database
func (m *{{ .ormStruct }}) TagGet(ctx context.Context, tag string, cond dbhelper.CondFunc) (*{{ .fullName }}, error) {
	b := m.ORM.SelectFromForTag(m.Table, tag)
	cond(b)

	var result {{ .fullName }}
	expr, args := b.Build()
	if err := m.ORM.TagQueryRow(ctx, m.DB, &result, tag, expr, args...); err != nil {
		ecmlog.ErrorEx(ctx, "TagQueryRow failed", "err", err)
		return nil, err
	}
	return &result, nil
}

// Get getting {{ .fullName }} from database
func (m *{{ .ormStruct }}) Get(ctx context.Context, cond dbhelper.CondFunc) (*{{ .fullName }}, error) {
	return m.TagGet(ctx, "", cond)
}

// TagPull pulling {{ .fullName }} from database
func (m *{{ .ormStruct }}) TagPull(ctx context.Context, tag string, cond dbhelper.CondFunc) ([]{{ .fullName }}, error) {
	b := m.ORM.SelectFromForTag(m.Table, tag)
	cond(b)

	var result []{{ .fullName }}
	expr, args := b.Build()
	if err := m.ORM.TagQuery(ctx, m.DB, &result, tag, expr, args...); err != nil {
		ecmlog.ErrorEx(ctx, "TagQuery failed", "err", err)
		return nil, err
	}
	return result, nil
}

// Pull pulling {{ .fullName }} from database
func (m *{{ .ormStruct }}) Pull(ctx context.Context, cond dbhelper.CondFunc) ([]{{ .fullName }}, error) {
	return m.TagPull(ctx, "", cond)
}

{{ range $m, $t := .converters }}// Map{{$m}} mapping {{ $.fullName }} to it's {{$m}}
func (m *{{ $.ormStruct }}) Map{{$m}}(objs []{{ $.fullName }}, err error) (map[{{$t}}]*{{ $.fullName }}, error) {
	if err != nil {
		return nil, err
	}

	result := make(map[{{$t}}]*{{ $.fullName }}, len(objs))
	for i := range objs {
		result[objs[i].{{$m}}] = &objs[i]
	}
	return result, nil
}

{{ end -}}

{{ range $m, $t := .groupers }}// Group{{$m}} grouping {{ $.fullName }} by it's {{$m}}
func (m *{{ $.ormStruct }}) Group{{$m}}(objs []{{ $.fullName }}, err error) (map[{{$t}}][]{{ $.fullName }}, error) {
	if err != nil {
		return nil, err
	}

	result := make(map[{{$t}}][]{{ $.fullName }})
	for i := range objs {
		result[objs[i].{{$m}}] = append(result[objs[i].{{$m}}], objs[i])
	}
	return result, nil
}

{{ end -}}
